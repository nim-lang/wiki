<!DOCTYPE html>
<html lang="en-us">
<head>
  <title>nimwiki/Common_Criticisms.nim</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2280%22>üê≥</text></svg>">
  <meta content="text/html; charset=utf-8" http-equiv="content-type">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <link rel='stylesheet' href='https://unpkg.com/normalize.css'>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/kognise/water.css@latest/dist/light.min.css">
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/gh/pietroppeter/nimib/assets/atom-one-light.css'>
  <style>
.nb-box {
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.nb-small {
  font-size: 0.8rem;
}
button.nb-small {
  float: right;
  padding: 2px;
  padding-right: 5px;
  padding-left: 5px;
}
section#source {
  display:none
}

.nb-output {
  line-height: 1.15;
}
</style>
  
</head>
<body>
<header>
<div class="nb-box">
  <span><a href="..">üè°</a></span>
  <span><code>nimwiki/Common_Criticisms.nim</code></span>
  <span><a href="https://github.com/dlesnoff/nim-wiki"><svg aria-hidden="true" width="1.2em" height="1.2em" style="vertical-align: middle;" preserveAspectRatio="xMidYMid meet" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59c.4.07.55-.17.55-.38c0-.19-.01-.82-.01-1.49c-2.01.37-2.53-.49-2.69-.94c-.09-.23-.48-.94-.82-1.13c-.28-.15-.68-.52-.01-.53c.63-.01 1.08.58 1.23.82c.72 1.21 1.87.87 2.33.66c.07-.52.28-.87.51-1.07c-1.78-.2-3.64-.89-3.64-3.95c0-.87.31-1.59.82-2.15c-.08-.2-.36-1.02.08-2.12c0 0 .67-.21 2.2.82c.64-.18 1.32-.27 2-.27c.68 0 1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82c.44 1.1.16 1.92.08 2.12c.51.56.82 1.27.82 2.15c0 3.07-1.87 3.75-3.65 3.95c.29.25.54.73.54 1.48c0 1.07-.01 1.93-.01 2.2c0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z" fill="#000"></path></svg></a></span>
</div>
<hr>
</header><main>
<h2>Nim doesn't require call-site annotation for <code>var</code> parameters</h2>
<p>This is referring to systems like C#'s: <code>void foo(ref int myInput){...}; foo(ref a);</code>. Note the ref on the <code>foo</code> call. If this was Nim, it'd be impossible to tell from the call-site that <code>foo</code> has the potential to modify <code>a</code>.</p>
<p>Possibly. The problem here is that of what mental metaphor is being used. In many languages, heap allocation through pointers is the only method of having objects, and passing them to a function gives the freedom to modify them without any callsite annotations. In Nim, things can be allocated on the stack, and those things need to be treated in the same way as things on the heap.</p>
<pre><code class="language-nimrod">proc foo(input: var T) = ...
proc foo(input: ref T) = ...
let a: ref T = ...  # `let` says the value of the pointer is immutable
foo(a)  # valid, this is Java-style
var b: T = ...
foo(b)  # also valid
</code></pre>
<p>Note that the difference between what happens in Java and what Nim does is simply a matter of efficiency: Nim does not require our <code>T</code> to be allocated on the heap, and it certainly allows <code>b</code> to be declared with <code>let</code>, which will force an compile-time error to be thrown.</p>
<h2>Sum types are weird</h2>
<p>In OCaml, sum types are denoted like this:</p>
<pre><code class="language-ocaml"> type OptionalInt =
  | Value of int
  | Missing
</code></pre>
<p>while in Nim they are written like</p>
<pre><code class="language-nimrod">type
  NodeKind = enum opValue, opAdd, opSub, opMul, opCall
  Node = ref object
     case kind: NodeKind
     of opValue: value: int
     of opAdd, opSub, opMul, opCall: kids: seq[Node]
</code></pre>
<p>While the OCaml way looks better, the Nim version allows for multiple types to have the same values without repetition. It also has the advantage that multiple variants can concisely be matched upon using sets, eg <code>node.kind in {opSub, opMul}</code>.</p>
</main>
<footer>
<hr>
<div class="nb-box">
  <span><span class="nb-small">made with <a href="https://pietroppeter.github.io/nimib/">nimib üê≥</a></span></span>
  <span></span>
  <span><button class="nb-small" id="show" onclick="toggleSourceDisplay()">Show Source</button></span>
</div>
</footer>
<section id="source">
<pre><code class="nim hljs"><span class="hljs-keyword">import</span> strformat, strutils
<span class="hljs-keyword">import</span> nimib
<span class="hljs-keyword">import</span> nimoji

nbInit

nbText:<span class="hljs-string">&quot;&quot;&quot;
## Nim doesn't require call-site annotation for `var` parameters
This is referring to systems like C#'s: `void foo(ref int myInput){...}; foo(ref a);`. Note the ref on the `foo` call. If this was Nim, it'd be impossible to tell from the call-site that `foo` has the potential to modify `a`.

Possibly. The problem here is that of what mental metaphor is being used. In many languages, heap allocation through pointers is the only method of having objects, and passing them to a function gives the freedom to modify them without any callsite annotations. In Nim, things can be allocated on the stack, and those things need to be treated in the same way as things on the heap.

``` nimrod
proc foo(input: var T) = ...
proc foo(input: ref T) = ...
let a: ref T = ...  # `let` says the value of the pointer is immutable
foo(a)  # valid, this is Java-style
var b: T = ...
foo(b)  # also valid
```

Note that the difference between what happens in Java and what Nim does is simply a matter of efficiency: Nim does not require our `T` to be allocated on the heap, and it certainly allows `b` to be declared with `let`, which will force an compile-time error to be thrown.

## Sum types are weird
In OCaml, sum types are denoted like this:
``` ocaml
 type OptionalInt =
  | Value of int
  | Missing
```
while in Nim they are written like 
``` nimrod
type
  NodeKind = enum opValue, opAdd, opSub, opMul, opCall
  Node = ref object
     case kind: NodeKind
     of opValue: value: int
     of opAdd, opSub, opMul, opCall: kids: seq[Node]
```

While the OCaml way looks better, the Nim version allows for multiple types to have the same values without repetition. It also has the advantage that multiple variants can concisely be matched upon using sets, eg `node.kind in {opSub, opMul}`.
&quot;&quot;&quot;</span>
nbSave()
</code></pre>
</section><script>
function toggleSourceDisplay() {
  var btn = document.getElementById("show")
  var source = document.getElementById("source");
  if (btn.innerHTML=="Show Source") {
    btn.innerHTML = "Hide Source";
    source.style.display = "block";
  } else {
    btn.innerHTML = "Show Source";
    source.style.display = "none";
  }
}
</script></body>
</html>